Certainly, let's compile a comprehensive solution that includes user registration, database interactions for storing user and conversation data, and integrating Confluence content fetching using the atlassian-python-api. This all-in-one example is a cohesive solution for your requirements.

python
Copy code
from fastapi import FastAPI, HTTPException, Depends
from sqlalchemy import create_engine, Column, Integer, String, Boolean, DateTime, ForeignKey, Text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, relationship, Session
from pydantic import BaseModel
from datetime import datetime
from atlassian import Confluence
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Database setup
DATABASE_URL = os.getenv("DATABASE_URL", "mssql+pyodbc://username:password@hostname:port/databasename?driver=SQL+Server")
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# Database models
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True)
    confluence_space_key = Column(String)
    confluence_url = Column(String)
    confluence_access_token = Column(String)

class Conversation(Base):
    __tablename__ = 'conversations'
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey('users.id'))
    conversation_datetime = Column(DateTime, default=datetime.utcnow)
    was_useful = Column(Boolean)
    feedback_description = Column(Text)
    time_spent_seconds = Column(Integer)
    user = relationship("User", back_populates="conversations")

User.conversations = relationship("Conversation", order_by=Conversation.id, back_populates="user")

# FastAPI app setup
app = FastAPI()

# Pydantic models for request and response bodies
class UserRegistration(BaseModel):
    username: str
    confluence_space_key: str
    confluence_url: str
    confluence_access_token: str

class ChatQuery(BaseModel):
    username: str
    query: str
    was_useful: bool = True
    feedback_description: str = ""
    time_spent_seconds: int

# Dependency
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.post("/register/")
def register_user(user: UserRegistration, db: Session = Depends(get_db)):
    db_user = db.query(User).filter(User.username == user.username).first()
    if db_user:
        raise HTTPException(status_code=400, detail="Username already exists")
    new_user = User(**user.dict())
    db.add(new_user)
    db.commit()
    return {"message": f"User {user.username} registered successfully."}

@app.post("/chat/")
def chat_with_bot(query: ChatQuery, db: Session = Depends(get_db)):
    user = db.query(User).filter(User.username == query.username).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    confluence = Confluence(
        url=user.confluence_url,
        username='dummy',  # API token used in password field, username is not needed
        password=user.confluence_access_token
    )
    pages = confluence.get_all_pages_from_space(space=user.confluence_space_key, status="current")
    titles = [page['title'] for page in pages]

    new_conversation = Conversation(user_id=user.id, **query.dict())
    db.add(new_conversation)
    db.commit()

    return {"answer": f"Pages in your Confluence space include: {', '.join(titles)}"}

if __name__ == "__main__":
    Base.metadata.create_all(bind=engine)  # Create DB tables
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
Before running this script, make sure to:

Replace the placeholder DATABASE_URL in your .env file with your actual SQL Server connection string.
Ensure all required Python packages (fastapi, sqlalchemy, uvicorn, python-dotenv, atlassian-python-api, pyodbc) are installed.
Adjust any SQL Server-specific URL parameters as needed, depending on your SQL Server version and the ODBC driver you have installed.
This comprehensive solution includes:

SQL model definitions for users and conversations.
A /register/ endpoint for user registration, storing Confluence connection details in the database.
A /chat/ endpoint that fetches page titles from the specified Confluence space based on the user's stored credentials, simulating a chat response. It also logs the conversation details in the database, including whether the conversation was marked as useful



DATABASE_URL=mssql+pyodbc://username:password@hostname:port/databasename?driver=SQL+Server
CONFLUENCE_URL=https://your-confluence-site.atlassian.net/wiki
CONFLUENCE_API_TOKEN=your_confluence_api_token,
