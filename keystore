Copying over the KeyStore.jks file into your resources folder might work, but you still need to tell your application to use it explicitly. If youâ€™re still getting the same SSL error after copying it, Java is likely not using that keystore yet.


---

âœ… Steps to Ensure Java Uses the Copied Keystore

Since you copied the KeyStore.jks file into src/main/resources/, follow these steps:

1ï¸âƒ£ Configure Spring Boot to Use the Keystore

Add these properties to application.properties or application.yml:

For application.properties:

javax.net.ssl.trustStore=classpath:KeyStore.jks
javax.net.ssl.trustStorePassword=changeit

For application.yml:

javax:
  net:
    ssl:
      trustStore: classpath:KeyStore.jks
      trustStorePassword: changeit

Ensure the password matches the one used in the other project.

If changeit doesn't work, check the other projectâ€™s config for the actual password.



---

2ï¸âƒ£ Modify Java to Load the Keystore

If Spring Boot does not automatically use the keystore, set it manually in your T24Service class:

import javax.net.ssl.SSLContext;
import java.security.KeyStore;
import java.io.InputStream;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.netty.http.client.HttpClient;
import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;

@Service
public class T24Service {

    private final WebClient webClient;

    public T24Service() {
        this.webClient = WebClient.builder()
                .clientConnector(new ReactorClientHttpConnector(createHttpClient()))
                .baseUrl("https://u1vvar0d02.devg.rbc.com:9193")
                .build();
    }

    private HttpClient createHttpClient() {
        try {
            // Load keystore from resources
            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            InputStream keystoreStream = new ClassPathResource("KeyStore.jks").getInputStream();
            keyStore.load(keystoreStream, "changeit".toCharArray());

            // Build SSL context
            SslContext sslContext = SslContextBuilder.forClient()
                    .trustManager(InsecureTrustManagerFactory.INSTANCE) // Temporary for debugging
                    .build();

            return HttpClient.create().secure(sslContextSpec -> sslContextSpec.sslContext(sslContext));
        } catch (Exception e) {
            throw new RuntimeException("Failed to load keystore", e);
        }
    }
}

ğŸ”¹ This ensures WebClient loads the keystore from the resources folder.


---

3ï¸âƒ£ Restart the Application With JVM Arguments

If you prefer setting it via JVM arguments, start your application like this:

java -Djavax.net.ssl.trustStore=src/main/resources/KeyStore.jks \
     -Djavax.net.ssl.trustStorePassword=changeit \
     -jar your-app.jar

or in your application.properties:

spring.application.default-args=--javax.net.ssl.trustStore=classpath:KeyStore.jks --javax.net.ssl.trustStorePassword=changeit


---

4ï¸âƒ£ Debug If Java Is Using the Correct Keystore

Run your Spring Boot app with SSL debug logs:

java -Djavax.net.debug=ssl,handshake -jar your-app.jar

Look for:

trustStore is: src/main/resources/KeyStore.jks

If Java is not using your keystore, go back and set it using JVM arguments.


---

ğŸš€ Final Steps

âœ” Ensure KeyStore.jks is in src/main/resources/.
âœ” Update application.properties to point to the keystore.
âœ” Modify Java to explicitly load the keystore if necessary.
âœ” Restart and enable SSL debug logs (-Djavax.net.debug=ssl).

This should make your WebClient use the copied keystore correctly. Let me know if you still get SSL errors! ğŸš€

